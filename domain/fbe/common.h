// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

#pragma once

#include <array>
#include <bitset>
#include <cassert>
#include <cstring>
#include <list>
#include <map>
#include <memory>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <vector>

#if (__CYGWIN__)
#define MAYBE_UNUSED
#else
#define MAYBE_UNUSED [[maybe_unused]]
#endif

#if defined(__clang__) || defined(__CYGWIN__)
#include <experimental/optional>
#define stdoptional std::experimental::optional
#define stdnullopt std::experimental::nullopt
#else
#include <optional>
#define stdoptional std::optional
#define stdnullopt std::nullopt
#endif

#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
#include <time.h>
#elif defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#undef max
#undef min
#endif

namespace FBE {

// Register a new enum-based flags macro
#define ENUM_FLAGS(type)\
inline FBE::Flags<type> operator|(type f1, type f2) noexcept { return FBE::Flags<type>(f1) | FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator&(type f1, type f2) noexcept { return FBE::Flags<type>(f1) & FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator^(type f1, type f2) noexcept { return FBE::Flags<type>(f1) ^ FBE::Flags<type>(f2); }

// Enum-based flags
template <typename TEnum>
class Flags
{
    // Enum underlying type
    typedef typename std::make_unsigned<typename std::underlying_type<TEnum>::type>::type type;

public:
    Flags() noexcept : _value(0) {}
    explicit Flags(type value) noexcept : _value(value) {}
    explicit Flags(TEnum value) noexcept : _value((type)value) {}
    Flags(const Flags&) noexcept = default;
    Flags(Flags&&) noexcept = default;
    ~Flags() noexcept = default;

    Flags& operator=(type value) noexcept
    { _value = value; return *this; }
    Flags& operator=(TEnum value) noexcept
    { _value = (type)value; return *this; }
    Flags& operator=(const Flags&) noexcept = default;
    Flags& operator=(Flags&&) noexcept = default;

    // Is any flag set?
    explicit operator bool() const noexcept { return (_value != 0); }

    // Is no flag set?
    bool operator!() const noexcept { return (_value == 0); }

    // Reverse all flags
    Flags operator~() const noexcept { return Flags(~_value); }

    // Flags logical assign operators
    Flags& operator&=(const Flags& flags) noexcept
    { _value &= flags._value; return *this; }
    Flags& operator|=(const Flags& flags) noexcept
    { _value |= flags._value; return *this; }
    Flags& operator^=(const Flags& flags) noexcept
    { _value ^= flags._value; return *this; }

    // Flags logical friend operators
    friend Flags operator&(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value & flags2._value); }
    friend Flags operator|(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value | flags2._value); }
    friend Flags operator^(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value ^ flags2._value); }

    // Flags comparison
    friend bool operator==(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value == flags2._value; }
    friend bool operator!=(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value != flags2._value; }

    // Convert to the enum value
    operator TEnum() const noexcept { return (TEnum)_value; }

    // Get the enum value
    TEnum value() const noexcept { return (TEnum)_value; }
    // Get the underlying enum value
    type underlying() const noexcept { return _value; }
    // Get the bitset value
    std::bitset<sizeof(type) * 8> bitset() const noexcept { return {_value}; }

    // Swap two instances
    void swap(Flags& flags) noexcept { using std::swap; swap(_value, flags._value); }
    template <typename UEnum>
    friend void swap(Flags<UEnum>& flags1, Flags<UEnum>& flags2) noexcept;

private:
    type _value;
};

template <typename TEnum>
inline void swap(Flags<TEnum>& flags1, Flags<TEnum>& flags2) noexcept
{
    flags1.swap(flags2);
}

inline uint64_t utc()
{
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    struct timespec timestamp;
    if (clock_gettime(CLOCK_REALTIME, &timestamp) != 0)
        throw std::runtime_error("Cannot get value of CLOCK_REALTIME timer!");
    return (timestamp.tv_sec * 1000000000) + timestamp.tv_nsec;
#elif defined(_WIN32) || defined(_WIN64)
    FILETIME ft;
    GetSystemTimePreciseAsFileTime(&ft);

    ULARGE_INTEGER result;
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;
    return (result.QuadPart - 116444736000000000ull) * 100;
#endif
}

// Fast Binary Encoding write buffer based on the dynamic byte vector
class WriteBuffer
{
public:
    WriteBuffer() : _offset(0) {}
    // Initialize the write buffer with the given capacity
    explicit WriteBuffer(size_t capacity) : _offset(0) { reserve(capacity); }
    WriteBuffer(const WriteBuffer&) = default;
    WriteBuffer(WriteBuffer&&) noexcept = default;
    ~WriteBuffer() = default;

    WriteBuffer& operator=(const WriteBuffer&) = default;
    WriteBuffer& operator=(WriteBuffer&&) noexcept = default;

    const uint8_t* data() const noexcept { return _buffer.data(); }
    uint8_t* data() noexcept { return _buffer.data(); }
    size_t capacity() const noexcept { return _buffer.capacity(); }
    size_t size() const noexcept { return _buffer.size(); }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the end of the current buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((offset <= size) && "Invalid offset!");
        if (offset > size)
            throw std::invalid_argument("Invalid offset!");

        // Copy the given buffer starting from the given offset
        if (size > offset)
            _buffer.insert(_buffer.begin(), (const uint8_t*)data + offset, (const uint8_t*)data + size - offset);
        _offset = _buffer.size();
    }

    // Attach the given vector with a given offset to the end of the current buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((offset <= buffer.size()) && "Invalid offset!");
        if (offset <= buffer.size())
            throw std::invalid_argument("Invalid offset!");

        // Reset the current buffer
        reset();

        // Copy the given buffer starting from the given offset
        if (buffer.size() > offset)
            _buffer.insert(_buffer.begin(), buffer.begin() + offset, buffer.end() - offset);
        _offset = _buffer.size();
    }

    // Allocate memory in the current write buffer and return offset to the allocated memory block
    size_t allocate(size_t size)
    {
        assert((size > 0) && "Invalid allocate size!");
        if (size <= 0)
            throw std::invalid_argument("Invalid allocate size!");

        size_t offset = _buffer.size();
        _buffer.resize(offset + size);
        return offset;
    }

    // Remove some memory of the given size from the current write buffer
    void remove(size_t offset, size_t size)
    {
        assert(((offset + size) <= _buffer.size()) && "Invalid offset & size!");
        if ((offset + size) > _buffer.size())
            throw std::invalid_argument("Invalid offset & size!");

        _buffer.erase(_buffer.begin() + offset, _buffer.begin() + offset + size);
        if (_offset >= (offset + size))
            _offset -= size;
        else if (_offset >= offset)
        {
            _offset -= _offset - offset;
            if (_offset > _buffer.size())
                _offset = _buffer.size();
        }
    }

    // Reserve memory of the given capacity in the current write buffer
    void reserve(size_t capacity) { _buffer.reserve(capacity); }

    // Reset the current write buffer and its offset
    void reset()
    {
        _buffer.clear();
        _offset = 0;
    }

    // Shift the current write buffer offset
    void shift(size_t offset) { _offset += offset; }
    // Unshift the current write buffer offset
    void unshift(size_t offset) { _offset -= offset; }

private:
    std::vector<uint8_t> _buffer;
    size_t _offset;
};

// Fast Binary Encoding read buffer based on the constant byte buffer
class ReadBuffer
{
public:
    ReadBuffer() : _data(nullptr), _size(0), _offset(0) {}
    // Initialize the read buffer with the given byte buffer and offset
    explicit ReadBuffer(const void* data, size_t size, size_t offset = 0) { attach(data, size, offset); }
    // Initialize the read buffer with the given byte vector and offset
    explicit ReadBuffer(const std::vector<uint8_t>& buffer, size_t offset = 0) { attach(buffer, offset); }
    // Initialize the read buffer with another read buffer and offset
    explicit ReadBuffer(const ReadBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    // Initialize the read buffer with another write buffer and offset
    explicit ReadBuffer(const WriteBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    ReadBuffer(ReadBuffer&&) noexcept = default;
    ~ReadBuffer() = default;

    ReadBuffer& operator=(const ReadBuffer&) = default;
    ReadBuffer& operator=(ReadBuffer&&) noexcept = default;

    const uint8_t* data() const noexcept { return _data; }
    size_t capacity() const noexcept { return _size; }
    size_t size() const noexcept { return _size; }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the current read buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            throw std::invalid_argument("Invalid buffer!");
        assert((size > 0) && "Invalid size!");
        if (size == 0)
            throw std::invalid_argument("Invalid size!");
        assert((offset <= size) && "Invalid offset!");
        if (offset > size)
            throw std::invalid_argument("Invalid offset!");

        _data = (const uint8_t*)data;
        _size = size;
        _offset = offset;
    }

    // Attach the given byte vector with a given offset to the current read buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((buffer.data() != nullptr) && "Invalid buffer!");
        if (buffer.data() == nullptr)
            throw std::invalid_argument("Invalid buffer!");
        assert((buffer.size() > 0) && "Invalid size!");
        if (buffer.size() == 0)
            throw std::invalid_argument("Invalid size!");
        assert((offset <= buffer.size()) && "Invalid offset!");
        if (offset > buffer.size())
            throw std::invalid_argument("Invalid offset!");

        _data = buffer.data();
        _size = buffer.size();
        _offset = offset;
    }

    // Allocate fake method
    size_t allocate(size_t size)
    {
        assert(false && "Cannot allocate using the read buffer!");
        throw std::logic_error("Cannot allocate using the read buffer!");
    }

    // Remove fake method
    void remove(size_t offset, size_t size)
    {
        assert(false && "Cannot remove from the read buffer!");
        throw std::logic_error("Cannot remove from the read buffer!");
    }

    // Reserve fake method
    void reserve(size_t capacity)
    {
        assert(false && "Cannot reserve using the read buffer!");
        throw std::logic_error("Cannot reserve using the read buffer!");
    }

    // Reset the current read buffer and its offset
    void reset()
    {
        _data = nullptr;
        _size = 0;
        _offset = 0;
    }

    // Shift the current read buffer offset
    void shift(size_t size) { _offset += size; }
    // Unshift the current read buffer offset
    void unshift(size_t size) { _offset -= size; }

private:
    const uint8_t* _data;
    size_t _size;
    size_t _offset;
};

// Fast Binary Encoding base model class
template <class TBuffer>
class Model
{
public:
    Model() : Model(nullptr) {}
    Model(const std::shared_ptr<TBuffer>& buffer) { attach((buffer) ? buffer : std::make_shared<TBuffer>()); }
    Model(const Model&) = default;
    Model(Model&&) noexcept = default;
    ~Model() = default;

    Model& operator=(const Model&) = default;
    Model& operator=(Model&&) noexcept = default;

    // Get the model buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Attach the model buffer
    void attach(const void* data, size_t size, size_t offset = 0) { _buffer->attach(data, size, offset); }
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0) { _buffer->attach(buffer, offset); }
    void attach(const ReadBuffer& buffer, size_t offset = 0) { _buffer->attach(buffer.data(), buffer.size(), offset); }
    void attach(const WriteBuffer& buffer, size_t offset = 0) { _buffer->attach(buffer.data(), buffer.size(), offset); }
    void attach(const std::shared_ptr<TBuffer>& buffer)
    {
        assert(buffer && "Attached buffer should be valid!");
        if (!buffer)
            throw std::invalid_argument("Attached buffer should be valid!");

        _buffer = buffer;
    }
    void attach(const std::shared_ptr<TBuffer>& buffer, size_t offset)
    {
        attach(buffer);
        _buffer->unshift(_buffer->offset());
        _buffer->shift(offset);
    }

    // Model buffer operations
    size_t allocate(size_t size) { return _buffer->allocate(size); }
    void remove(size_t offset, size_t size) { _buffer->remove(offset, size); }
    void reserve(size_t capacity) { _buffer->reserve(capacity); }
    void reset() { _buffer->reset(); }
    void shift(size_t offset) { _buffer->shift(offset); }
    void unshift(size_t offset) { _buffer->unshift(offset); }

private:
    std::shared_ptr<TBuffer> _buffer;
};

// Fast Binary Encoding base field model class
template <class TBuffer, typename T, typename TBase = T>
class FieldModelBase
{
public:
    FieldModelBase(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return sizeof(TBase); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    bool verify() const noexcept { return true; }

    // Get the field value
    void get(T& value, T defaults = (T)0) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        {
            value = defaults;
            return;
        }

        value = (T)(*((const TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())));
    }

    // Set the field value
    void set(T value) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        *((TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (TBase)value;
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class
template <class TBuffer, typename T>
class FieldModel : public FieldModelBase<TBuffer, T>
{
public:
    using FieldModelBase<TBuffer, T>::FieldModelBase;
};

// Fast Binary Encoding field model class bool specialization
template <class TBuffer>
class FieldModel<TBuffer, bool> : public FieldModelBase<TBuffer, bool, uint8_t>
{
public:
    using FieldModelBase<TBuffer, bool, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model class char specialization
template <class TBuffer>
class FieldModel<TBuffer, char> : public FieldModelBase<TBuffer, char, uint8_t>
{
public:
    using FieldModelBase<TBuffer, char, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model class wchar specialization
template <class TBuffer>
class FieldModel<TBuffer, wchar_t> : public FieldModelBase<TBuffer, wchar_t, uint32_t>
{
public:
    using FieldModelBase<TBuffer, wchar_t, uint32_t>::FieldModelBase;
};

// Fast Binary Encoding field model class bytes specialization
template <class TBuffer>
class FieldModel<TBuffer, std::vector<uint8_t>>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        return (size_t)(4 + fbe_bytes_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return 0;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_bytes_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), result);
        return result;
    }

    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept
    {
        return get(data, N);
    }

    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept
    {
        return get(data.data(), data.size());
    }

    // Get the bytes value
    void get(std::vector<uint8_t>& value) const noexcept
    {
        value.clear();

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return;

        const char* fbe_bytes = (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4);
        value.assign(fbe_bytes, fbe_bytes + fbe_bytes_size);
    }

    // Set the bytes value
    void set(const void* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = (uint32_t)size;
        uint32_t fbe_bytes_offset = (uint32_t)(_buffer.allocate(4 + fbe_bytes_size) - _buffer.offset());
        assert(((fbe_bytes_offset > 0) && ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_bytes_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset)) = fbe_bytes_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), data, fbe_bytes_size);
    }

    // Set the bytes value
    template <size_t N>
    void set(const uint8_t (&data)[N])
    {
        return set(data, N);
    }

    // Set the bytes value
    template <size_t N>
    void set(const std::array<uint8_t, N>& data)
    {
        return set(data.data(), data.size());
    }

    // Set the bytes value
    void set(const std::vector<uint8_t>& value) { set(value.data(), value.size()); }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class string specialization
template <class TBuffer>
class FieldModel<TBuffer, std::string>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        return (size_t)(4 + fbe_string_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_string_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the string value
    size_t get(char* data, size_t size) const noexcept
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return 0;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_string_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_string_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), result);
        return result;
    }

    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept
    {
        return get(data, N);
    }

    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept
    {
        return get(data.data(), data.size());
    }

    // Get the string value
    void get(std::string& value, const std::string& defaults = "") const noexcept
    {
        value = defaults;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return;

        value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
    }

    // Set the string value
    void set(const char* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)size;
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), data, fbe_string_size);
    }

    // Set the string value
    template <size_t N>
    void set(const char (&data)[N])
    {
        return set(data, N);
    }

    // Set the string value
    template <size_t N>
    void set(const std::array<char, N>& data)
    {
        return set(data.data(), data.size());
    }

    // Set the string value
    void set(const std::string& value)
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)value.size();
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), value.data(), fbe_string_size);
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class optional specialization
template <class TBuffer, typename T>
class FieldModel<TBuffer, stdoptional<T>>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 1 + 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_optional_offset);
        size_t fbe_result = value.fbe_size() + value.fbe_extra();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks whether the object contains a value
    bool has_value() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return false;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return (fbe_has_value != 0);
    }

    // Check if the optional value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_has_value == 0)
            return true;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        if (fbe_optional_offset == 0)
            return false;

        _buffer.shift(fbe_optional_offset);
        bool fbe_result = value.verify();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Get the optional value (being phase)
    size_t get_begin() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        assert((fbe_optional_offset > 0) && "Model is broken!");

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Get the optional value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the optional value
    void get(stdoptional<T>& opt, const stdoptional<T>& defaults = stdnullopt) const noexcept
    {
        opt = defaults;

        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        T temp;
        value.get(temp);
        opt.emplace(temp);

        get_end(fbe_begin);
    }

    // Set the optional value (begin phase)
    size_t set_begin(bool has_value)
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint8_t fbe_has_value = has_value ? 1 : 0;
        *((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
        if (fbe_has_value == 0)
            return 0;

        uint32_t fbe_optional_size = (uint32_t)value.fbe_size();
        uint32_t fbe_optional_offset = (uint32_t)(_buffer.allocate(fbe_optional_size) - _buffer.offset());
        assert(((fbe_optional_offset > 0) && ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1)) = fbe_optional_offset;

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Set the optional value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the optional value
    void set(const stdoptional<T>& opt)
    {
        size_t fbe_begin = set_begin(opt.has_value());
        if (fbe_begin == 0)
            return;

        if (opt.has_value())
            value.set(opt.value());

        set_end(fbe_begin);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, T> value;
};

// Fast Binary Encoding field model array class
template <class TBuffer, typename T, size_t N>
class FieldModelArray
{
public:
    FieldModelArray(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), _fbe_model(buffer, offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return N * _fbe_model.fbe_size(); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Array value index operator
    FieldModel<TBuffer, T> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        assert((index < N) && "Index is out of bounds!");

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        fbe_model.fbe_shift(index * fbe_model.fbe_size());
        return fbe_model;
    }

    const uint8_t* data() const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        return _buffer.data() + _buffer.offset() + fbe_offset();
    }
    uint8_t* data() noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        return _buffer.data() + _buffer.offset() + fbe_offset();
    }
    // Get the array value offset
    size_t offset() const noexcept { return 0; }
    // Get the array value size
    size_t size() const noexcept { return N; }

    // Check if the array value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = N; i-- > 0;)
        {
            if (!fbe_model.verify())
                return false;
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }

        return true;
    }

    // Get the array value as C-array
    template <size_t S>
    void get(T (&values)[S]) const noexcept
    {
        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.get(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array value as std::array
    template <size_t S>
    void get(std::array<T, S>& values) const noexcept
    {
        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.get(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array value as std::vector
    void get(std::vector<T>& values) const noexcept
    {
        values.clear();
        values.reserve(N);

        auto fbe_model = (*this)[0];
        for (size_t i = N; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as C-array
    template <size_t S>
    void set(const T (&values)[S]) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as std::array
    template <size_t S>
    void set(const std::array<T, S>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as std::vector
    void set(const std::vector<T>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < values.size()) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
    FieldModel<TBuffer, T> _fbe_model;
};

// Fast Binary Encoding field model vector class
template <class TBuffer, typename T>
class FieldModelVector
{
public:
    FieldModelVector(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            fbe_result += fbe_model.fbe_size() + fbe_model.fbe_extra();
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Vector value index operator
    FieldModel<TBuffer, T> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

        MAYBE_UNUSED uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
        assert((index < fbe_vector_size) && "Index is out of bounds!");
        (void)fbe_vector_size;

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        fbe_model.fbe_shift(index * fbe_model.fbe_size());
        return fbe_model;
    }

    // Get the vector value offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return fbe_vector_offset;
    }

    // Get the vector value size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
        return fbe_vector_size;
    }

    // Resize the vector and get its first model
    FieldModel<TBuffer, T> resize(size_t size)
    {
        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());

        uint32_t fbe_vector_size = (uint32_t)(size * fbe_model.fbe_size());
        uint32_t fbe_vector_offset = (uint32_t)(_buffer.allocate(4 + fbe_vector_size) - _buffer.offset());
        assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_vector_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_vector_offset + 4), 0, fbe_vector_size);

        return FieldModel<TBuffer, T>(_buffer, fbe_vector_offset + 4);
    }

    // Check if the vector value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_vector_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            if (!fbe_model.verify())
                return false;
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }

        return true;
    }

    // Get the vector value as std::vector
    void get(std::vector<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        values.reserve(fbe_vector_size);

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the vector value as std::list
    void get(std::list<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the vector value as std::set
    void get(std::set<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as std::vector
    void set(const std::vector<T>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as std::list
    void set(const std::list<T>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector value as std::set
    void set(const std::set<T>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model map class
template <class TBuffer, typename TKey, typename TValue>
class FieldModelMap
{
public:
    FieldModelMap(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            fbe_result += fbe_model_key.fbe_size() + fbe_model_key.fbe_extra();
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());

            fbe_result += fbe_model_value.fbe_size() + fbe_model_value.fbe_extra();
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Map value index operator
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4) <= _buffer.size())) && "Model is broken!");

        MAYBE_UNUSED uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        assert((index < fbe_map_size) && "Index is out of bounds!");
        (void)fbe_map_size;

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        fbe_model_key.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        fbe_model_value.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        return std::make_pair(fbe_model_key, fbe_model_value);
    }

    // Get the map value offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return fbe_map_offset;
    }

    // Get the map value size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        return fbe_map_size;
    }

    // Resize the map and get its first model
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> resize(size_t size)
    {
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset());
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + fbe_model_key.fbe_size());

        uint32_t fbe_map_size = (uint32_t)(size * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        uint32_t fbe_map_offset = (uint32_t)(_buffer.allocate(4 + fbe_map_size) - _buffer.offset());
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4 + fbe_map_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_map_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_map_offset + 4), 0, fbe_map_size);

        return std::make_pair(FieldModel<TBuffer, TKey>(_buffer, fbe_map_offset + 4), FieldModel<TBuffer, TValue>(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size()));
    }

    // Check if the map value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_map_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            if (!fbe_model_key.verify())
                return false;
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());

            if (!fbe_model_value.verify())
                return false;
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }

        return true;
    }

    // Get the map value as std::map
    void get(std::map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            fbe_model.first.get(key);
            fbe_model.second.get(value);
            values.emplace(key, value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Get the map value as std::unordered_map
    void get(std::unordered_map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            fbe_model.first.get(key);
            fbe_model.second.get(value);
            values.emplace(key, value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map value as std::map
    void set(const std::map<TKey, TValue>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());

            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map value as std::unordered_map
    void set(const std::unordered_map<TKey, TValue>& values) noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());

            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding base sender class
template <class TBuffer>
class Sender
{
public:
    Sender() : _logging(false) { _buffer = std::make_shared<TBuffer>(); }
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    // Get the sender buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Attach the sender buffer
    virtual void attach(const std::shared_ptr<TBuffer>& buffer)
    {
        assert(buffer && "Attached buffer should be valid!");
        if (!buffer)
            throw std::invalid_argument("Attached buffer should be valid!");

        _buffer = buffer;
    }
    void attach(const std::shared_ptr<TBuffer>& buffer, size_t offset)
    {
        attach(buffer);
        _buffer->unshift(_buffer->offset());
        _buffer->shift(offset);
    }

    // Send serialized buffer. Direct call of the method requires knowledge about internals of FBE models serialization. Use it with care!
    size_t send_serialized(size_t serialized)
    {
        assert((serialized > 0) && "Invalid size of the serialized buffer!");

        // Shift the send buffer
        this->_buffer->shift(serialized);

        // Send the value
        size_t sent = onSend(this->_buffer->data(), this->_buffer->size());
        this->_buffer->remove(0, sent);
        return sent;
    }

protected:
    // Send message handler
    virtual size_t onSend(const void* data, size_t size) = 0;
    // Send logging handler
    virtual void onSendLog(const std::string& message) const {}

protected:
    std::shared_ptr<TBuffer> _buffer;
    bool _logging;
};

// Fast Binary Encoding base receiver class
template <class TBuffer>
class Receiver
{
public:
    Receiver() : _logging(false) { _buffer = std::make_shared<TBuffer>(); }
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) noexcept = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) noexcept = default;

    // Get the receiver buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Attach the receiver buffer
    virtual void attach(const std::shared_ptr<TBuffer>& buffer)
    {
        assert(buffer && "Attached buffer should be valid!");
        if (!buffer)
            throw std::invalid_argument("Attached buffer should be valid!");

        _buffer = buffer;
    }
    void attach(const std::shared_ptr<TBuffer>& buffer, size_t offset)
    {
        attach(buffer);
        _buffer->unshift(_buffer->offset());
        _buffer->shift(offset);
    }

    // Receive data
    void receive(const void* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return;

        if (size == 0)
            return;

        // Storage buffer
        uint8_t* buffer1 = _buffer->data();
        size_t offset0 = _buffer->offset();
        size_t offset1 = _buffer->size();
        size_t size1 = _buffer->size();

        // Receive buffer
        const uint8_t* buffer2 = (const uint8_t*)data;
        size_t offset2 = 0;
        size_t size2 = size;

        // While receive buffer is available to handle...
        while (offset2 < size2)
        {
            const uint8_t* message_buffer = nullptr;
            size_t message_size = 0;

            // Try to receive message size
            bool message_size_copied = false;
            bool message_size_found = false;
            while (!message_size_found)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    size_t count = std::min(size1 - offset0, (size_t)4);
                    if (count == 4)
                    {
                        message_size_copied = true;
                        message_size_found = true;
                        message_size = (size_t)(*((const uint32_t*)(buffer1 + offset0)));
                        offset0 += 4;
                        break;
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size2)
                        {
                            count = std::min(size2 - offset2, 4 - count);

                            // Allocate and refresh the storage buffer
                            _buffer->allocate(count);
                            buffer1 = _buffer->data();
                            size1 += count;

                            memcpy(buffer1 + offset1, buffer2 + offset2, count);
                            offset1 += count;
                            offset2 += count;
                            continue;
                        }
                        else
                            break;
                    }
                }

                // Look into the receive buffer
                if (offset2 < size2)
                {
                    size_t count = std::min(size2 - offset2, (size_t)4);
                    if (count == 4)
                    {
                        message_size_found = true;
                        message_size = (size_t)(*((const uint32_t*)(buffer2 + offset2)));
                        offset2 += 4;
                        break;
                    }
                    else
                    {
                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                }
                else
                    break;
            }

            if (!message_size_found)
                return;

            // Check the message full size
            assert((message_size >= (4 + 4 + 4 + 4)) && "Invalid receive data!");
            if (message_size < (4 + 4 + 4 + 4))
                return;

            // Try to receive message body
            bool message_found = false;
            while (!message_found)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    size_t count = std::min(size1 - offset0, message_size - 4);
                    if (count == (message_size - 4))
                    {
                        message_found = true;
                        message_buffer = buffer1 + offset0 - 4;
                        offset0 += message_size - 4;
                        break;
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size2)
                        {
                            // Copy message size into the storage buffer
                            if (!message_size_copied)
                            {
                                // Allocate and refresh the storage buffer
                                _buffer->allocate(4);
                                buffer1 = _buffer->data();
                                size1 += 4;

                                *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                                offset0 += 4;
                                offset1 += 4;

                                message_size_copied = true;
                            }

                            count = std::min(size2 - offset2, message_size - 4 - count);

                            // Allocate and refresh the storage buffer
                            _buffer->allocate(count);
                            buffer1 = _buffer->data();
                            size1 += count;

                            memcpy(buffer1 + offset1, buffer2 + offset2, count);
                            offset1 += count;
                            offset2 += count;
                            continue;
                        }
                        else
                            break;
                    }
                }

                // Look into the receive buffer
                if (offset2 < size2)
                {
                    size_t count = std::min(size2 - offset2, message_size - 4);
                    if (!message_size_copied && (count == (message_size - 4)))
                    {
                        message_found = true;
                        message_buffer = buffer2 + offset2 - 4;
                        offset2 += message_size - 4;
                        break;
                    }
                    else
                    {
                        // Copy message size into the storage buffer
                        if (!message_size_copied)
                        {
                            // Allocate and refresh the storage buffer
                            _buffer->allocate(4);
                            buffer1 = _buffer->data();
                            size1 += 4;

                            *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                            offset0 += 4;
                            offset1 += 4;

                            message_size_copied = true;
                        }

                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                }
                else
                    break;
            }

            if (!message_found)
            {
                // Copy message size into the storage buffer
                if (!message_size_copied)
                {
                    // Allocate and refresh the storage buffer
                    _buffer->allocate(4);
                    buffer1 = _buffer->data();
                    size1 += 4;

                    *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                    offset0 += 4;
                    offset1 += 4;

                    message_size_copied = true;
                }
                return;
            }

            // Read the message parameters
            uint32_t fbe_struct_offset = *((const uint32_t*)(message_buffer + 4));
            MAYBE_UNUSED uint32_t fbe_struct_size = *((const uint32_t*)(message_buffer + fbe_struct_offset));
            (void)fbe_struct_size;
            uint32_t fbe_struct_type = *((const uint32_t*)(message_buffer + fbe_struct_offset + 4));

            // Handle the message
            onReceive(fbe_struct_type, message_buffer, message_size);

            // Reset the storage buffer
            _buffer->reset();

            // Refresh the storage buffer
            buffer1 = _buffer->data();
            offset1 = _buffer->offset();
            size1 = _buffer->size();
        }
    }

protected:
    // Receive message handler
    virtual bool onReceive(size_t type, const void* data, size_t size) = 0;
    // Receive logging handler
    virtual void onReceiveLog(const std::string& message) const {}

protected:
    std::shared_ptr<TBuffer> _buffer;
    bool _logging;
};

} // namespace FBE
