// Automatically generated by the Fast Binary Encoding compiler, do not modify!

#pragma once

#include <array>
#include <bitset>
#include <cassert>
#include <cstring>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <vector>

#if defined(__clang__) || defined(__CYGWIN__)
#include <experimental/optional>
#define stdoptional std::experimental::optional
#define stdnullopt std::experimental::nullopt
#else
#include <optional>
#define stdoptional std::optional
#define stdnullopt std::nullopt
#endif

#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
#include <time.h>
#elif defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#endif

namespace FBE {

// Register a new enum-based flags macro
#define ENUM_FLAGS(type)\
inline FBE::Flags<type> operator|(type f1, type f2) noexcept { return FBE::Flags<type>(f1) | FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator&(type f1, type f2) noexcept { return FBE::Flags<type>(f1) & FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator^(type f1, type f2) noexcept { return FBE::Flags<type>(f1) ^ FBE::Flags<type>(f2); }

// Enum-based flags
template <typename TEnum>
class Flags
{
    // Enum underlying type
    typedef typename std::make_unsigned<typename std::underlying_type<TEnum>::type>::type type;

public:
    Flags() noexcept : _value(0) {}
    explicit Flags(type value) noexcept : _value(value) {}
    explicit Flags(TEnum value) noexcept : _value((type)value) {}
    Flags(const Flags&) noexcept = default;
    Flags(Flags&&) noexcept = default;
    ~Flags() noexcept = default;

    Flags& operator=(type value) noexcept
    { _value = value; return *this; }
    Flags& operator=(TEnum value) noexcept
    { _value = (type)value; return *this; }
    Flags& operator=(const Flags&) noexcept = default;
    Flags& operator=(Flags&&) noexcept = default;

    // Is any flag set?
    explicit operator bool() const noexcept { return (_value != 0); }

    // Is no flag set?
    bool operator!() const noexcept { return (_value == 0); }

    // Reverse all flags
    Flags operator~() const noexcept { return Flags(~_value); }

    // Flags logical assign operators
    Flags& operator&=(const Flags& flags) noexcept
    { _value &= flags._value; return *this; }
    Flags& operator|=(const Flags& flags) noexcept
    { _value |= flags._value; return *this; }
    Flags& operator^=(const Flags& flags) noexcept
    { _value ^= flags._value; return *this; }

    // Flags logical friend operators
    friend Flags operator&(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value & flags2._value); }
    friend Flags operator|(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value | flags2._value); }
    friend Flags operator^(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value ^ flags2._value); }

    // Flags comparison
    friend bool operator==(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value == flags2._value; }
    friend bool operator!=(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value != flags2._value; }

    // Convert to the enum value
    operator TEnum() const noexcept { return (TEnum)_value; }

    // Get the enum value
    TEnum value() const noexcept { return (TEnum)_value; }
    // Get the underlying enum value
    type underlying() const noexcept { return _value; }
    // Get the bitset value
    std::bitset<sizeof(type) * 8> bitset() const noexcept { return {_value}; }

    // Swap two instances
    void swap(Flags& flags) noexcept { using std::swap; swap(_value, flags._value); }
    template <typename UEnum>
    friend void swap(Flags<UEnum>& flags1, Flags<UEnum>& flags2) noexcept;

private:
    type _value;
};

template <typename TEnum>
inline void swap(Flags<TEnum>& flags1, Flags<TEnum>& flags2) noexcept
{
    flags1.swap(flags2);
}

inline uint64_t utc()
{
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    struct timespec timestamp;
    if (clock_gettime(CLOCK_REALTIME, &timestamp) != 0)
        throw std::runtime_error("Cannot get value of CLOCK_REALTIME timer!");
    return (timestamp.tv_sec * 1000000000) + timestamp.tv_nsec;
#elif defined(_WIN32) || defined(_WIN64)
    FILETIME ft;
    GetSystemTimePreciseAsFileTime(&ft);

    ULARGE_INTEGER result;
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;
    return (result.QuadPart - 116444736000000000ull) * 100;
#endif
}

// Fast Binary Encoding write buffer based on the dynamic byte vector
class WriteBuffer
{
public:
    WriteBuffer() : _offset(0) {}
    // Initialize the write buffer with the given capacity
    explicit WriteBuffer(size_t capacity) : _offset(0) { reserve(capacity); }
    WriteBuffer(const WriteBuffer&) = default;
    WriteBuffer(WriteBuffer&&) noexcept = default;
    ~WriteBuffer() = default;

    WriteBuffer& operator=(const WriteBuffer&) = default;
    WriteBuffer& operator=(WriteBuffer&&) noexcept = default;

    const uint8_t* data() const noexcept { return _buffer.data(); }
    uint8_t* data() noexcept { return _buffer.data(); }
    size_t capacity() const noexcept { return _buffer.capacity(); }
    size_t size() const noexcept { return _buffer.size(); }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the end of the current buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((offset < size) && "Invalid offset!");

        // Copy the given buffer starting from the given offset
        if (size > offset)
            _buffer.insert(_buffer.begin(), (const uint8_t*)data + offset, (const uint8_t*)data + size - offset);
        _offset = _buffer.size();
    }

    // Attach the given vector with a given offset to the end of the current buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((offset < buffer.size()) && "Invalid offset!");

        // Reset the current buffer
        reset();

        // Copy the given buffer starting from the given offset
        if (buffer.size() > offset)
            _buffer.insert(_buffer.begin(), buffer.begin() + offset, buffer.end() - offset);
        _offset = _buffer.size();
    }

    // Allocate memory in the current write buffer and return offset to the allocated memory block
    size_t allocate(size_t size)
    {
        size_t offset = _buffer.size();
        _buffer.resize(offset + size);
        return offset;
    }

    // Reserve memory of the given capacity in the current write buffer
    void reserve(size_t capacity) { _buffer.reserve(capacity); }

    // Reset the current write buffer and its offset
    void reset()
    {
        _buffer.clear();
        _offset = 0;
    }

    // Shift the current write buffer offset
    void shift(size_t offset) { _offset += offset; }
    // Unshift the current write buffer offset
    void unshift(size_t offset) { _offset -= offset; }

private:
    std::vector<uint8_t> _buffer;
    size_t _offset;
};

// Fast Binary Encoding read buffer based on the constant byte buffer
class ReadBuffer
{
public:
    ReadBuffer() : _data(nullptr), _size(0), _offset(0) {}
    // Initialize the read buffer with the given byte buffer and offset
    explicit ReadBuffer(const void* data, size_t size, size_t offset = 0) { attach(data, size, offset); }
    // Initialize the read buffer with the given byte vector and offset
    explicit ReadBuffer(const std::vector<uint8_t>& buffer, size_t offset = 0) { attach(buffer, offset); }
    // Initialize the read buffer with another read buffer and offset
    explicit ReadBuffer(const ReadBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    // Initialize the read buffer with another write buffer and offset
    explicit ReadBuffer(const WriteBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    ReadBuffer(ReadBuffer&&) noexcept = default;
    ~ReadBuffer() = default;

    ReadBuffer& operator=(const ReadBuffer&) = default;
    ReadBuffer& operator=(ReadBuffer&&) noexcept = default;

    const uint8_t* data() const noexcept { return _data; }
    size_t capacity() const noexcept { return _size; }
    size_t size() const noexcept { return _size; }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the current read buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((data != nullptr) && "Invalid buffer!");
        assert((size > 0) && "Invalid size!");
        assert((offset < size) && "Invalid offset!");

        _data = (const uint8_t*)data;
        _size = size;
        _offset = offset;
    }

    // Attach the given byte vector with a given offset to the current read buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((buffer.data() != nullptr) && "Invalid buffer!");
        assert((buffer.size() > 0) && "Invalid size!");
        assert((offset < buffer.size()) && "Invalid offset!");

        _data = buffer.data();
        _size = buffer.size();
        _offset = offset;
    }

    // Allocate fake method
    size_t allocate(size_t size)
    {
        assert(false && "Cannot allocate using read buffer!");
        throw std::logic_error("Cannot allocate using read buffer!");
    }

    // Reserve fake method
    void reserve(size_t capacity)
    {
        assert(false && "Cannot reserve using read buffer!");
        throw std::logic_error("Cannot reserve using read buffer!");
    }

    // Reset the current read buffer and its offset
    void reset()
    {
        _data = nullptr;
        _size = 0;
        _offset = 0;
    }

    // Shift the current read buffer offset
    void shift(size_t size) { _offset += size; }
    // Unshift the current read buffer offset
    void unshift(size_t size) { _offset -= size; }

private:
    const uint8_t* _data;
    size_t _size;
    size_t _offset;
};

// Fast Binary Encoding model base class
template <class TBuffer>
class Model
{
public:
    Model() = default;
    Model(const Model&) = delete;
    Model(Model&&) noexcept = default;
    ~Model() = default;

    Model& operator=(const Model&) = delete;
    Model& operator=(Model&&) noexcept = default;

    // Get the model buffer
    TBuffer& buffer() noexcept { return _buffer; }
    const TBuffer& buffer() const noexcept { return _buffer; }

    // Attach the model buffer
    void attach(const void* data, size_t size, size_t offset = 0) { _buffer.attach(data, size, offset); }
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0) { _buffer.attach(buffer, offset); }
    void attach(const ReadBuffer& buffer, size_t offset = 0) { _buffer.attach(buffer.data(), buffer.size(), offset); }
    void attach(const WriteBuffer& buffer, size_t offset = 0) { _buffer.attach(buffer.data(), buffer.size(), offset); }

    // Model buffer operations
    size_t allocate(size_t size) { return _buffer.allocate(size); }
    void reserve(size_t capacity) { _buffer.reserve(capacity); }
    void reset() { _buffer.reset(); }
    void shift(size_t offset) { _buffer.shift(offset); }
    void unshift(size_t offset) { _buffer.unshift(offset); }

private:
    TBuffer _buffer;
};

// Fast Binary Encoding field model base class
template <class TBuffer, typename T, typename TBase = T>
class FieldModelBase
{
public:
    FieldModelBase(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return sizeof(TBase); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    bool verify() const noexcept { return true; }

    // Get the field value
    void get(T& value, T default_value = (T)0) const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
        {
            value = default_value;
            return;
        }

        value = (T)(*((const TBase*)(_buffer.data() + _buffer.offset() + _offset)));
    }

    // Set the field value
    void set(T value) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        *((TBase*)(_buffer.data() + _buffer.offset() + _offset)) = (TBase)value;
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class
template <class TBuffer, typename T>
class FieldModel : public FieldModelBase<TBuffer, T>
{
public:
    using FieldModelBase<TBuffer, T>::FieldModelBase;
};

// Fast Binary Encoding field model class bool specialization
template <class TBuffer>
class FieldModel<TBuffer, bool> : public FieldModelBase<TBuffer, bool, uint8_t>
{
public:
    using FieldModelBase<TBuffer, bool, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model class char specialization
template <class TBuffer>
class FieldModel<TBuffer, char> : public FieldModelBase<TBuffer, char, uint8_t>
{
public:
    using FieldModelBase<TBuffer, char, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model class wchar specialization
template <class TBuffer>
class FieldModel<TBuffer, wchar_t> : public FieldModelBase<TBuffer, wchar_t, uint32_t>
{
public:
    using FieldModelBase<TBuffer, wchar_t, uint32_t>::FieldModelBase;
};

// Fast Binary Encoding field model class bytes specialization
template <class TBuffer>
class FieldModel<TBuffer, std::vector<uint8_t>>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        return (size_t)(4 + fbe_bytes_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_bytes_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept
    {
        assert((data != nullptr) && "Invalid buffer!");
        assert((size > 0) && "Invalid size!");

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_bytes_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_bytes_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), result);
        return result;
    }

    // Get the bytes value
    template <std::size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept
    {
        return get(data, N);
    }

    // Get the bytes value
    template <std::size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept
    {
        return get(data.data(), data.size());
    }

    // Get the bytes value
    void get(std::vector<uint8_t>& value) const noexcept
    {
        value.clear();

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_bytes_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return;

        const char* fbe_bytes = (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4);
        value.assign(fbe_bytes, fbe_bytes + fbe_bytes_size);
    }

    // Set the bytes value
    void set(const void* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        assert((size > 0) && "Invalid size!");

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = (uint32_t)size;
        uint32_t fbe_bytes_offset = (uint32_t)(_buffer.allocate(4 + fbe_bytes_size) - _buffer.offset());
        assert(((fbe_bytes_offset > 0) && ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_bytes_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset)) = fbe_bytes_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), data, fbe_bytes_size);
    }

    // Set the bytes value
    template <std::size_t N>
    void set(const uint8_t (&data)[N])
    {
        return set(data, N);
    }

    // Set the bytes value
    template <std::size_t N>
    void set(const std::array<uint8_t, N>& data)
    {
        return set(data.data(), data.size());
    }

    // Set the bytes value
    void set(const std::vector<uint8_t>& value) { set(value.data(), value.size()); }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class string specialization
template <class TBuffer>
class FieldModel<TBuffer, std::string>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        return (size_t)(4 + fbe_string_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the string value
    size_t get(char* data, size_t size) const noexcept
    {
        assert((data != nullptr) && "Invalid buffer!");
        assert((size > 0) && "Invalid size!");

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_string_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), result);
        return result;
    }

    // Get the string value
    template <std::size_t N>
    size_t get(char (&data)[N]) const noexcept
    {
        return get(data, N);
    }

    // Get the string value
    template <std::size_t N>
    size_t get(std::array<char, N>& data) const noexcept
    {
        return get(data.data(), data.size());
    }

    // Get the string value
    void get(std::string& value, const std::string& default_value = "") const noexcept
    {
        value = default_value;

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return;

        value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
    }

    // Set the string value
    void set(const char* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        assert((size > 0) && "Invalid size!");

        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)size;
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), data, fbe_string_size);
    }

    // Set the string value
    template <std::size_t N>
    void set(const char (&data)[N])
    {
        return set(data, N);
    }

    // Set the string value
    template <std::size_t N>
    void set(const std::array<char, N>& data)
    {
        return set(data.data(), data.size());
    }

    // Set the string value
    void set(const std::string& value)
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)value.size();
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), value.data(), fbe_string_size);
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model class optional specialization
template <class TBuffer, typename T>
class FieldModel<TBuffer, stdoptional<T>>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 1 + 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset + 1));
        if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_optional_offset);
        size_t fbe_result = value.fbe_size() + value.fbe_extra();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks whether the object contains a value
    bool has_value() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return false;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + _offset));
        return (fbe_has_value != 0);
    }

    // Check if the optional value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return true;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_has_value == 0)
            return true;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset + 1));
        if (fbe_optional_offset == 0)
            return false;

        _buffer.shift(fbe_optional_offset);
        bool fbe_result = value.verify();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Get the optional value (being phase)
    size_t get_begin() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset + 1));
        assert((fbe_optional_offset > 0) && "Model is broken!");

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Get the optional value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the optional value
    void get(stdoptional<T>& opt, const stdoptional<T>& default_value = stdnullopt) const noexcept
    {
        opt = default_value;

        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        T temp;
        value.get(temp);
        opt.emplace(temp);

        get_end(fbe_begin);
    }

    // Set the optional value (begin phase)
    size_t set_begin(bool has_value)
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint8_t fbe_has_value = has_value ? 1 : 0;
        *((uint8_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_has_value;
        if (fbe_has_value == 0)
            return 0;

        uint32_t fbe_optional_size = (uint32_t)value.fbe_size();
        uint32_t fbe_optional_offset = (uint32_t)(_buffer.allocate(fbe_optional_size) - _buffer.offset());
        assert(((fbe_optional_offset > 0) && ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset + 1)) = fbe_optional_offset;

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Set the optional value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the optional value
    void set(const stdoptional<T>& opt)
    {
        size_t fbe_begin = set_begin(opt.has_value());
        if (fbe_begin == 0)
            return;

        value.set(opt.value());

        set_end(fbe_begin);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, T> value;
};

// Fast Binary Encoding field model array class
template <class TBuffer, typename T>
class FieldModelArray
{
public:
    FieldModelArray(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_array_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_array_offset == 0) || ((_buffer.offset() + fbe_array_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_array_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_array_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_array_offset + 4);
        for (size_t i = fbe_array_size; i-- > 0;)
        {
            fbe_result += fbe_model.fbe_size() + fbe_model.fbe_extra();
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Array value index operators
    FieldModel<TBuffer, T> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + _offset + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_array_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        assert(((fbe_array_offset > 0) && ((_buffer.offset() + fbe_array_offset + 4) <= _buffer.size())) && "Model is broken!");

        uint32_t fbe_array_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_array_offset));
        assert((index < fbe_array_size) && "Index is out of bounds!");
        (void)fbe_array_size;

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_array_offset + 4);
        fbe_model.fbe_shift(index * fbe_model.fbe_size());
        return fbe_model;
    }

    // Get the array value offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_array_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        return fbe_array_offset;
    }

    // Get the array value size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_array_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_array_offset == 0) || ((_buffer.offset() + fbe_array_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_array_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_array_offset));
        return fbe_array_size;
    }

    // Resize the array and get its first model
    FieldModel<TBuffer, T> resize(size_t size)
    {
        FieldModel<TBuffer, T> fbe_model(_buffer, _offset);

        uint32_t fbe_array_size = (uint32_t)(size * fbe_model.fbe_size());
        uint32_t fbe_array_offset = (uint32_t)(_buffer.allocate(4 + fbe_array_size) - _buffer.offset());
        assert(((fbe_array_offset > 0) && ((_buffer.offset() + fbe_array_offset + 4) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_array_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_array_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_array_offset + 4), 0, fbe_array_size);

        return FieldModel<TBuffer, T>(_buffer, fbe_array_offset + 4);
    }

    // Check if the array value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_array_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_array_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_array_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_array_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_array_offset));

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_array_offset + 4);
        for (size_t i = fbe_array_size; i-- > 0;)
        {
            if (!fbe_model.verify())
                return false;
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }

        return true;
    }

    // Get the array value as std::vector
    void get(std::vector<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_array_size = size();
        if (fbe_array_size == 0)
            return;

        values.reserve(fbe_array_size);

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_array_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array value as std::list
    void get(std::list<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_array_size = size();
        if (fbe_array_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_array_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array value as std::set
    void get(std::set<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_array_size = size();
        if (fbe_array_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_array_size; i-- > 0;)
        {
            T value;
            fbe_model.get(value);
            values.emplace(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array value as std::vector
    void set(const std::vector<T>& values) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array value as std::list
    void set(const std::list<T>& values) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array value as std::set
    void set(const std::set<T>& values) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model map class
template <class TBuffer, typename TKey, typename TValue>
class FieldModelMap
{
public:
    FieldModelMap(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            fbe_result += fbe_model_key.fbe_size() + fbe_model_key.fbe_extra();
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());

            fbe_result += fbe_model_value.fbe_size() + fbe_model_value.fbe_extra();
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Map value index operators
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + _offset + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4) <= _buffer.size())) && "Model is broken!");

        [[maybe_unused]] uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        assert((index < fbe_map_size) && "Index is out of bounds!");

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        fbe_model_key.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        fbe_model_value.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        return std::make_pair(fbe_model_key, fbe_model_value);
    }

    // Get the map value offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        return fbe_map_offset;
    }

    // Get the map value size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        return fbe_map_size;
    }

    // Resize the map and get its first model
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> resize(size_t size)
    {
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, _offset);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, _offset + fbe_model_key.fbe_size());

        uint32_t fbe_map_size = (uint32_t)(size * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        uint32_t fbe_map_offset = (uint32_t)(_buffer.allocate(4 + fbe_map_size) - _buffer.offset());
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4 + fbe_map_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + _offset)) = fbe_map_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_map_offset + 4), 0, fbe_map_size);

        return std::make_pair(FieldModel<TBuffer, TKey>(_buffer, fbe_map_offset + 4), FieldModel<TBuffer, TValue>(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size()));
    }

    // Check if the map value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_map_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            if (!fbe_model_key.verify())
                return false;
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());

            if (!fbe_model_value.verify())
                return false;
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }

        return true;
    }

    // Get the map value as std::map
    void get(std::map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey fbe_key;
            TValue fbe_value;
            fbe_model.first.get(fbe_key);
            fbe_model.second.get(fbe_value);
            values.emplace(fbe_key, fbe_value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Get the map value as std::unordered_map
    void get(std::unordered_map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey fbe_key;
            TValue fbe_value;
            fbe_model.first.get(fbe_key);
            fbe_model.second.get(fbe_value);
            values.emplace(fbe_key, fbe_value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map value as std::map
    void set(const std::map<TKey, TValue>& values) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());

            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map value as std::unordered_map
    void set(const std::unordered_map<TKey, TValue>& values) noexcept
    {
        if ((_buffer.offset() + _offset + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());

            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

} // namespace FBE
